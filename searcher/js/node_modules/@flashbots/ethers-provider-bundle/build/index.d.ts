import { BlockTag, TransactionReceipt, TransactionRequest } from '@ethersproject/abstract-provider';
import { Networkish } from '@ethersproject/networks';
import { BaseProvider } from '@ethersproject/providers';
import { ConnectionInfo } from '@ethersproject/web';
import { BigNumber, providers, Signer } from 'ethers';
export declare const DEFAULT_FLASHBOTS_RELAY = "https://relay.flashbots.net";
export declare const BASE_FEE_MAX_CHANGE_DENOMINATOR = 8;
export declare enum FlashbotsBundleResolution {
    BundleIncluded = 0,
    BlockPassedWithoutInclusion = 1,
    AccountNonceTooHigh = 2
}
export declare enum FlashbotsTransactionResolution {
    TransactionIncluded = 0,
    TransactionDropped = 1
}
export declare enum FlashbotsBundleConflictType {
    NoConflict = 0,
    NonceCollision = 1,
    Error = 2,
    CoinbasePayment = 3,
    GasUsed = 4,
    NoBundlesInBlock = 5
}
export interface FlashbotsBundleRawTransaction {
    signedTransaction: string;
}
export interface FlashbotsBundleTransaction {
    transaction: TransactionRequest;
    signer: Signer;
}
export interface FlashbotsOptions {
    minTimestamp?: number;
    maxTimestamp?: number;
    revertingTxHashes?: Array<string>;
}
export interface TransactionAccountNonce {
    hash: string;
    signedTransaction: string;
    account: string;
    nonce: number;
}
export interface FlashbotsTransactionResponse {
    bundleTransactions: Array<TransactionAccountNonce>;
    wait: () => Promise<FlashbotsBundleResolution>;
    simulate: () => Promise<SimulationResponse>;
    receipts: () => Promise<Array<TransactionReceipt>>;
    bundleHash: string;
}
export interface FlashbotsPrivateTransactionResponse {
    transaction: TransactionAccountNonce;
    wait: () => Promise<FlashbotsTransactionResolution>;
    simulate: () => Promise<SimulationResponse>;
    receipts: () => Promise<Array<TransactionReceipt>>;
}
export interface TransactionSimulationBase {
    txHash: string;
    gasUsed: number;
    gasFees: string;
    gasPrice: string;
    toAddress: string;
    fromAddress: string;
}
export interface TransactionSimulationSuccess extends TransactionSimulationBase {
    value: string;
    ethSentToCoinbase: string;
}
export interface TransactionSimulationRevert extends TransactionSimulationBase {
    error: string;
    revert: string;
}
export declare type TransactionSimulation = TransactionSimulationSuccess | TransactionSimulationRevert;
export interface RelayResponseError {
    error: {
        message: string;
        code: number;
    };
}
export interface SimulationResponseSuccess {
    bundleHash: string;
    coinbaseDiff: BigNumber;
    results: Array<TransactionSimulation>;
    totalGasUsed: number;
    firstRevert?: TransactionSimulation;
}
export declare type SimulationResponse = SimulationResponseSuccess | RelayResponseError;
export declare type FlashbotsTransaction = FlashbotsTransactionResponse | RelayResponseError;
export declare type FlashbotsPrivateTransaction = FlashbotsPrivateTransactionResponse | RelayResponseError;
export interface GetUserStatsResponseSuccess {
    signing_address: string;
    blocks_won_total: number;
    bundles_submitted_total: number;
    bundles_error_total: number;
    avg_gas_price_gwei: number;
    blocks_won_last_7d: number;
    bundles_submitted_last_7d: number;
    bundles_error_7d: number;
    avg_gas_price_gwei_last_7d: number;
    blocks_won_last_numberd: number;
    bundles_submitted_last_numberd: number;
    bundles_error_numberd: number;
    avg_gas_price_gwei_last_numberd: number;
    blocks_won_last_numberh: number;
    bundles_submitted_last_numberh: number;
    bundles_error_numberh: number;
    avg_gas_price_gwei_last_numberh: number;
    blocks_won_last_5m: number;
    bundles_submitted_last_5m: number;
    bundles_error_5m: number;
    avg_gas_price_gwei_last_5m: number;
}
export declare type GetUserStatsResponse = GetUserStatsResponseSuccess | RelayResponseError;
export interface GetBundleStatsResponseSuccess {
    isSimulated: boolean;
    isSentToMiners: boolean;
    isHighPriority: boolean;
    simulatedAt: string;
    submittedAt: string;
    sentToMinersAt: string;
}
export declare type GetBundleStatsResponse = GetBundleStatsResponseSuccess | RelayResponseError;
interface BlocksApiResponseTransactionDetails {
    transaction_hash: string;
    tx_index: number;
    bundle_type: 'rogue' | 'flashbots';
    bundle_index: number;
    block_number: number;
    eoa_address: string;
    to_address: string;
    gas_used: number;
    gas_price: string;
    coinbase_transfer: string;
    total_miner_reward: string;
}
interface BlocksApiResponseBlockDetails {
    block_number: number;
    miner_reward: string;
    miner: string;
    coinbase_transfers: string;
    gas_used: number;
    gas_price: string;
    transactions: Array<BlocksApiResponseTransactionDetails>;
}
export interface BlocksApiResponse {
    latest_block_number: number;
    blocks: Array<BlocksApiResponseBlockDetails>;
}
export interface FlashbotsBundleConflict {
    conflictingBundle: Array<BlocksApiResponseTransactionDetails>;
    initialSimulation: SimulationResponseSuccess;
    conflictType: FlashbotsBundleConflictType;
}
export interface FlashbotsGasPricing {
    txCount: number;
    gasUsed: number;
    gasFeesPaidBySearcher: BigNumber;
    priorityFeesReceivedByMiner: BigNumber;
    ethSentToCoinbase: BigNumber;
    effectiveGasPriceToSearcher: BigNumber;
    effectivePriorityFeeToMiner: BigNumber;
}
export interface FlashbotsBundleConflictWithGasPricing extends FlashbotsBundleConflict {
    targetBundleGasPricing: FlashbotsGasPricing;
    conflictingBundleGasPricing?: FlashbotsGasPricing;
}
export declare class FlashbotsBundleProvider extends providers.JsonRpcProvider {
    private genericProvider;
    private authSigner;
    private connectionInfo;
    constructor(genericProvider: BaseProvider, authSigner: Signer, connectionInfoOrUrl: ConnectionInfo, network: Networkish);
    static throttleCallback(): Promise<boolean>;
    static create(genericProvider: BaseProvider, authSigner: Signer, connectionInfoOrUrl?: ConnectionInfo | string, network?: Networkish): Promise<FlashbotsBundleProvider>;
    static getMaxBaseFeeInFutureBlock(baseFee: BigNumber, blocksInFuture: number): BigNumber;
    static getBaseFeeInNextBlock(currentBaseFeePerGas: BigNumber, currentGasUsed: BigNumber, currentGasLimit: BigNumber): BigNumber;
    static generateBundleHash(txHashes: Array<string>): string;
    sendRawBundle(signedBundledTransactions: Array<string>, targetBlockNumber: number, opts?: FlashbotsOptions): Promise<FlashbotsTransaction>;
    sendBundle(bundledTransactions: Array<FlashbotsBundleTransaction | FlashbotsBundleRawTransaction>, targetBlockNumber: number, opts?: FlashbotsOptions): Promise<FlashbotsTransaction>;
    sendPrivateTransaction(transaction: FlashbotsBundleTransaction | FlashbotsBundleRawTransaction, opts?: {
        maxBlockNumber?: number;
        simulationTimestamp?: number;
    }): Promise<FlashbotsPrivateTransaction>;
    cancelPrivateTransaction(txHash: string): Promise<boolean | RelayResponseError>;
    signBundle(bundledTransactions: Array<FlashbotsBundleTransaction | FlashbotsBundleRawTransaction>): Promise<Array<string>>;
    private waitForBlock;
    private waitForTxInclusion;
    getUserStats(): Promise<GetUserStatsResponse>;
    getBundleStats(bundleHash: string, blockNumber: number): Promise<GetBundleStatsResponse>;
    simulate(signedBundledTransactions: Array<string>, blockTag: BlockTag, stateBlockTag?: BlockTag, blockTimestamp?: number): Promise<SimulationResponse>;
    private calculateBundlePricing;
    getConflictingBundle(targetSignedBundledTransactions: Array<string>, targetBlockNumber: number): Promise<FlashbotsBundleConflictWithGasPricing>;
    getConflictingBundleWithoutGasPricing(targetSignedBundledTransactions: Array<string>, targetBlockNumber: number): Promise<FlashbotsBundleConflict>;
    fetchBlocksApi(blockNumber: number): Promise<BlocksApiResponse>;
    private request;
    private fetchReceipts;
    private prepareRelayRequest;
}
export {};
